package org.lared.desinventar.webobject;

import java.io.*;
import java.util.*;
import java.sql.*;
import java.math.*;
import java.text.*;

import javax.servlet.*;
import javax.servlet.http.*;
import javax.servlet.jsp.*;
import javax.servlet.jsp.tagext.*;

import org.lared.desinventar.util.*;
import org.lared.desinventar.system.*;
import org.lared.desinventar.webobject.*;


// Initially generated by webObjectGenerator, and HEAVILY customized.
// WARNING:  DO NOT RE-GENERATE THIS CLASS!!
public class extension
    extends webObject
{
  // DATA MEMBERS OF THE CLASS. THEY ARE EXACT MAPPING OF DB. RECORD.
  public int clave_ext;

  // this ArrayList will hold the extended fields
  public ArrayList<diccionario> vFields = new ArrayList<diccionario>();

  // this ArrayList will hold the extension tabs
  public ArrayList<extensiontabs> vTabs = new ArrayList<extensiontabs>();

  // this ArrayList will hold the extension field names as they appear in the resultset
  public HashMap<String,Integer> vMeta = new HashMap<String,Integer>();
  public ArrayList<String> aMeta = new ArrayList<String>();
 
  // SQL metadata of the resultset 
  transient ResultSetMetaData meta;
  
  public static final int Types_Oracle_Date = 93; // this is what oracle returns instead of Types.Date
  public static final int Types_Oracle_CLOB = 1111; // this is what oracle returns instead of Types.CLOB?

  private DICountry countrybean=null;

  public static final int TEXT=0;
  public static final int INTEGER=1;
  public static final int FLOATINGPOINT=2;
  public static final int CURRENCY=3;
  public static final int DATETIME=4;
  public static final int MEMO=5;
  public static final int YESNO=6;
  public static final int LIST=7;
  public static final int CHOICE=8;
  
  public static final String[] UserTypeNames={"TEXT","INTEGER","FLOATING POINT","CURRENCY","DATE-TIME","MEMO","YES/NO","LIST","MULTIPLE-CHOICE"};

  //--------------------------------------------------------------------------------
  // creates a hash table with field values of the data members
  //--------------------------------------------------------------------------------

  public void updateHashTable()
  {
    // FIELD NAMES ArrayList

    asFieldNames.put("clave_ext", String.valueOf(clave_ext));
    for (int j = 0; j < vFields.size(); j++)
      asFieldNames.put( ( (Dictionary) vFields.get(j)).nombre_campo,
                       ( (Dictionary) vFields.get(j)).sValue);

  }

	//--------------------------------------------------------------------------------
	// update data members with values stored in hash table
	//--------------------------------------------------------------------------------

	public void updateMembersFromHashTable() {
		// REVERSE FIELD NAMES VECTOR
		if (asFieldNames.get("CLAVE_EXT")!=null)
			setClave_ext((String)asFieldNames.get("CLAVE_EXT")); // XML import does this
		else
			setClave_ext((String)asFieldNames.get("clave_ext"));
		
	    for (int j = 0; j < vFields.size(); j++)
	    {
	    	Dictionary dct= (Dictionary) vFields.get(j);
	        dct.sValue=dct.not_null((String )asFieldNames.get(dct.nombre_campo));	        
	        switch (dct.fieldtype) /// was: .nDataType)
	        {
	        case TEXT:
	        	// truncates if needed
	        	if (dct.sValue.length()>dct.lon_x)
	        		dct.sValue=dct.sValue.substring(0,dct.lon_x);
	        	break;
	        case YESNO:
	        case LIST:
	        case CHOICE:
	        case INTEGER:
	            dct.dNumericValue=extendedParseInt(dct.sValue);
	            break;
	        case FLOATINGPOINT:
	        case CURRENCY:
	            dct.dNumericValue=extendedParseDouble(dct.sValue);
	            break;
	        case DATETIME:
	        case MEMO:
	        	break;
	        }

	    }

	}

	//--------------------------------------------------------------------------------
	// update data members with values stored in hash table
	//--------------------------------------------------------------------------------

	public void checkLengths() 
	{
	    for (int j = 0; j < vFields.size(); j++)
	    {
	    	try{
		    	Dictionary dct= (Dictionary) vFields.get(j);
		        if (dct.fieldtype==TEXT)
		        {
		        	// truncates if needed
		        	if (dct.sValue!=null && dct.sValue.length()>dct.lon_x)
		        		dct.sValue=dct.sValue.substring(0,dct.lon_x);
		        	break;
		        }
	    		
	    	}
	    	catch (Exception e)
	    	{
	    		// nothing for now
	    	}
	    }
	}

  //--------------------------------------------------------------------------------
  // constructor of the class. it initializes the object variables
  //--------------------------------------------------------------------------------

  // CONSTRUCTOR
  public void init()
  {
    lastError = "NO errors detected";
    clave_ext = 0;
    for (int j = 0; j < vFields.size(); j++)
        {
          ((Dictionary) vFields.get(j)).sValue="";
          ((Dictionary) vFields.get(j)).dNumericValue=0;
        }
    updateHashTable();
  }

  public void loadExtension(Connection con, DICountry countrybean)
  {
    int j = 0;
    lastError = "NO errors detected";
    clave_ext = 0;
    vFields = new ArrayList();
    vTabs = new ArrayList();
    aMeta = new ArrayList<String>();
    this.countrybean=countrybean;

    try
    {
      stmt = con.createStatement ();
      Statement stmt_d = con.createStatement ();
      Statement stmt_c = con.createStatement ();
      // will always be an empty recset...
      sSql = "select * from extension where clave_ext=-1";
      rset = stmt.executeQuery(sSql);
      // gets the metadata of the resultset
      meta = rset.getMetaData();
      
      // loads all the extended datacard fields in a ArrayList, in Dictionary order!!!
      sSql = "select * from diccionario order by orden";
      ResultSet rset_d = stmt_d.executeQuery(sSql);
      int nWithoutTabs=0;
      int nReg=0;
      while (rset_d.next())
      {
        // allocates a new object for each record
        Dictionary dct = new Dictionary();
        // loads all the table field
        dct.loadWebObject(rset_d);
        if (dct.tabnumber==0)
        	nWithoutTabs++;
        // default datatype
        dct.nDataType = Types.VARCHAR;
        if (dct.label_campo.length()==0)
          dct.label_campo=dct.nombre_campo;
        // searches its datatype in the table metadata
        for (j = 1; j <= meta.getColumnCount(); j++)
        {
          // search by field name
          String sCol = meta.getColumnName(j).toUpperCase();
          if (dct.nombre_campo.equalsIgnoreCase(sCol))
            {
              dct.nDataType = meta.getColumnType(j);
              dct.lon_x=meta.getColumnDisplaySize(j);
              dct.nombre_campo=meta.getColumnName(j).toUpperCase(); // MySql would have a lowercase - oracle an uppercase, etc...
          	  vMeta.put(sCol,nReg);  
            }
        }
        // TODO:   load extension codes here!
        if (dct.fieldtype>=LIST)
        	{
			sSql = "SELECT * FROM extensioncodes WHERE field_name = '"+dct.nombre_campo+"' order by nsort";
            ResultSet rset_c = stmt_c.executeQuery(sSql);
            while (rset_c.next())
	            {
	            extensioncodes ec = new extensioncodes();
	            ec.loadWebObject(rset_c);
	            dct.codes.add(ec);
	            }
        	}
        // adds the field to the ArrayList
        vFields.add(dct);
        nReg++;
      }
      // and stores the sequence in order to read (load) it exactly in the same order AND CASE!, but only variables declared in the dictionary!
      for (j = 1; j <= meta.getColumnCount(); j++)
    	  if (vMeta.get(meta.getColumnName(j).toUpperCase())!=null)
    		  aMeta.add(meta.getColumnName(j));

      // loads all the extended datacard TABS in a ArrayList, in order!!!
      sSql = "select * from extensiontabs order by nsort";
      rset_d = stmt_d.executeQuery(sSql);
      while (rset_d.next())
      {
          // allocates a new object for each record
    	  extensiontabs tab = new extensiontabs();
          // loads all the table field
    	  tab.loadWebObject(rset_d);
          // adds the tab to the ArrayList
    	  vTabs.add(tab);
      }
      // adds the default tab if Needed only
      if (vTabs.size()==0 || nWithoutTabs>0){
    	  extensiontabs extab = new extensiontabs();
	      extab.svalue=countrybean.getTranslation("Extension");
	      extab.svalue_en="Extension";
    	  vTabs.add(extab);
      }

    	try{rset.close();}catch(Exception e){/* do nothing for now */ }
      	try{rset_d.close();}catch(Exception e){/* do nothing for now */ }
      	try{stmt.close();}catch(Exception e){/* do nothing for now */ }
      	try{stmt_c.close();}catch(Exception e){/* do nothing for now */ }
      	try{stmt_d.close();}catch(Exception e){/* do nothing for now */ }


    }
    catch (Exception e)
    {
      lastError = e.toString();
    }

    updateHashTable();
    // adds the extension variable titles to the core translator
    countrybean.vmVmanager=new VariableManager();
    countrybean.vmVmanager.addExtensionVariables(this,countrybean);
  }

  public extension(int dataBaseType)
  {
    super("extension object");
    init();
    this.dbType=dataBaseType;
  }

  public extension()
  {
    super("extension object");
    init();
  }

//--------------------------------------------------------------------------------
// getter and setter methods of the elements of the class
//--------------------------------------------------------------------------------

//--------------------------------------------------------------------------------
// METHODS FOR: clave_ext
  public String getClave_ext()
  {
    return Integer.toString(clave_ext);
  }

  public void setClave_ext(String sParameter)
  {
    clave_ext = extendedParseInt(sParameter);
  }

// end of methodhs for Clave_ext

  public String getValue(String variable, String value)
  {
      int j=vMeta.get(variable.toUpperCase());
      if (j>=vFields.size())
			return value;    	  
      Dictionary dct= (Dictionary) vFields.get(j);
      dct.sValue=value;
      switch (dct.fieldtype)
	  	{
        case extension.DATETIME:
			return value; //strDate(value); whatever the database says.... formatting problems here!
        case extension.CURRENCY:
			return formatDouble(extendedParseDouble(value));
        case extension.FLOATINGPOINT:
			return formatDouble(extendedParseDouble(value),-4); // ok, up to 4 relevant decs...
		case extension.YESNO:
			return value;
		case extension.LIST:
		case extension.CHOICE:
			return dct.getCodeValue(value,countrybean);
		default:
			return value;
		}

  }
  
  //----------------------------------------------------------------
  // Operational methods any webObject must have. Abstract class
  // provides templates and default behaviour (return error)
  //----------------------------------------------------------------

  //--------------------------------------------------------------------------------
  // retrieves object info from HTML form fields
  //--------------------------------------------------------------------------------
  public int getForm(HttpServletRequest req,
                     HttpServletResponse resp,
                     Connection con)
  {

    // GET_FORM()
    clave_ext = extendedParseInt(not_null(req.getParameter(assignName("clave_ext"))));
    // gets fields to the ArrayList
    // allocates a dictionary object to read each record
    Dictionary dct = new Dictionary();
    for (int j = 0; j < vFields.size(); j++)
    {
      dct = (Dictionary) vFields.get(j);
      dct.sValue=not_null(req.getParameter(dct.nombre_campo));
      switch (dct.nDataType)
      {
        case Types.DATE:
        case Types_Oracle_Date:
          dct.sValue=strDate(dct.sValue);
          break;
        case Types.DECIMAL:
        case Types.DOUBLE:
        case Types.FLOAT:
        case Types.NUMERIC:
        case Types.REAL:
          dct.dNumericValue=extendedParseDouble(dct.sValue);
          break;
        case Types.SMALLINT:
        case Types.INTEGER:
        case Types.TINYINT:
		  case Types.BIGINT:
          dct.dNumericValue=extendedParseInt(dct.sValue);
          break;
      }
    }
    updateHashTable();
    return 0;
  }

  //--------------------------------------------------------------------------------
  // loads an object from a record read from database
  //--------------------------------------------------------------------------------
  Dictionary dct=new Dictionary();
  public void loadWebObject(ResultSet rset)
  {
    try
    {
      // SQL_LOAD
      // this.clave_ext = rset.getInt("clave_ext");
      // allocates a dictionary object to read each record
      int nSize=this.aMeta.size();
      for (int k=0; k<nSize; k++)
      {
    	  try{
    		  
    		   	int j=vMeta.get(aMeta.get(k).toUpperCase());
    	        dct = (Dictionary) vFields.get(j);
   	        
    	        if (dct.fieldtype==extension.MEMO && dct.dbType==Sys.iOracleDb)
    	        	dct.sValue= getClobString(rset.getClob(dct.nombre_campo));
    	        else
    	        	dct.sValue=not_null(rset.getString(dct.nombre_campo));
    	        dct.dNumericValue=extendedParseDouble(dct.sValue);
    	        if (dct.fieldtype==extension.DATETIME) 
    	        	{
    	            dct.sValue=strDate(dct.sValue);
    	        	}
    	     }
    	  catch (Exception eLoad)
    	     {
    		  // nothing for now. This allows for loading extension while importing
    	     }
      }
    }
    catch (Exception e)
    {
      this.lastError = "<!-Error loading WebObject: " + e.toString() + " : " + sSql + "-->";
      System.out.println("<!-Error loading WebObject: " + e.toString() + " : " + sSql + "-->");
    }
    updateHashTable();
  }

  //--------------------------------------------------------------------------------
  // reads an object from the database
  //--------------------------------------------------------------------------------
  public int getWebObject(Connection con)
  {
    try
    {
      // creates the statement handle
      stmt = con.createStatement ();
      String sVars=" ";
      Dictionary dct = new Dictionary();

      // This is justto guarantee the fields are loaded in the same order as the were read
      for (int j = 0; j < vFields.size(); j++)
      {
        dct = (Dictionary) vFields.get(j);
        sVars+=","+dct.nombre_campo;        
      }
      sSql = "SELECT clave_ext"+sVars+" FROM extension";
      sSql += " WHERE (CLAVE_EXT=" + clave_ext + ")";

      rset = stmt.executeQuery(sSql);
      int nrows = 1;
      if (rset.next())
        loadWebObject(rset);
      else
        nrows = 0;
      // releases the result and statement objects
      rset.close();
      stmt.close();
      lastError = ""; // "NO ERROR. sql="+sSql;
      return nrows;
    }
    catch (Exception ex)
    {
        //Trap and report SQL errors
		lastError = "<!-Error getting persistentObject: " + ex.toString() + " : " + sSql + "-->";
    	try{rset.close();}catch(Exception e){/* do nothing for now */ }
    	try{stmt.close();}catch(Exception e){/* do nothing for now */ }
    }

    return -1;
  }

  // utility method to set all fields of a query
  private int setFields(Dictionary dct, int start)
  {
      for (int j = 0; j < vFields.size(); j++)
      {
    	try
    	{
        dct = (Dictionary) vFields.get(j);
        
        switch (dct.nDataType)
          {
          case Types.DATE:
          case Types_Oracle_Date:
              if (dct.sValue==null || dct.sValue.length()==0)
            	  pstmt.setNull(start,dct.nDataType);
              else
            	  pstmt.setDate(start, extendedParseDate(dct.sValue));
            break;
          case Types.DECIMAL:
          case Types.DOUBLE:
          case Types.FLOAT:
          case Types.NUMERIC:
          case Types.REAL:
            	  pstmt.setDouble(start, dct.dNumericValue);
            break;
          case Types.SMALLINT:
          case Types.INTEGER:
          case Types.TINYINT:
		  case Types.BIGINT:
            	  pstmt.setInt(start, (int) dct.dNumericValue);
            break;
          default:
              if (dct.sValue==null || dct.sValue.length()==0)
            	  pstmt.setNull(start, Types.VARCHAR);
              else
            	  {
  	        	  // truncates if needed
  	        	  if (dct.fieldtype==TEXT && dct.sValue.length()>dct.lon_x)
  	        		dct.sValue=dct.sValue.substring(0,dct.lon_x);
            	  pstmt.setString(start, dct.sValue);
            	  }
          }
    	}
    	catch (Exception e)
    	{
    	     lastError = "<!-DI9: Error setting persistentObject fields: " + e.toString() + " : " + sSql + "-->";
    	        	
    	}
        start++;
      }
  return start;
  }
  
  //--------------------------------------------------------------------------------
  // adds a new object to the database
  //--------------------------------------------------------------------------------
  public int addWebObject(Connection con)
  {

    try
    {
      // creates the statement handle
      String sVars="  ";
      String sValues="";
      Dictionary dct = new Dictionary();
      for (int j = 0; j < vFields.size(); j++)
      {
        dct = (Dictionary) vFields.get(j);
        sVars+=","+dct.nombre_campo;
        sValues+=",?";
      }

      // SQL_INSERT
      sSql = "insert into extension (clave_ext"+sVars;
      sSql += ") VALUES (?"+sValues+")";

	  pstmt=con.prepareStatement(sSql);
	  pstmt.setInt(1, clave_ext);
      setFields(dct,2);
      int nrows = 1;
      try
      	{
    	  nrows = pstmt.executeUpdate();
      	}
      catch (Exception e)
        {
    	  // ??? nothing to do for now...
		  System.out.println("[DI9] ERROR (adding webObject): EXTENSION "+e.toString());
          lastError = "<!-Error adding extension: " + e.toString() + " : " + sSql + "-->";
    	  nrows = 0;
        }			
      // releases the statement object
	  pstmt.close();
	  lastError = ""; // "NO ERROR. sql="+sSql;
      return nrows;
    }
    catch (Exception ex)
    {
      //Trap and report SQL errors
    	try{
	    	pstmt.close();
	    }
	    catch(Exception e)
	    {
	    	// do nothing for now
	    }
		lastError = "<!-Error adding persistentObject: " + ex.toString() + " : " + sSql + "-->";
      return -1;
    }
  }

  //--------------------------------------------------------------------------------
  // updates an existing object in the database
  //--------------------------------------------------------------------------------
  public int updateWebObject(Connection con)
  {
    try
    {
      // creates the statement handle
      stmt = con.createStatement ();
      String sValues="";
      Dictionary dct = new Dictionary();
      for (int j = 0; j < vFields.size(); j++)
      {
        dct = (Dictionary) vFields.get(j);
        if (j>0)
          sValues+=",";
        sValues+=dct.nombre_campo+"=?";
      }

      
      int nrows = 0;
      if (sValues.length()>0) // if anything to update
      	{
          // SQL_UPDATE
          sSql = "UPDATE extension SET "+sValues+" WHERE (CLAVE_EXT=?)";
    	  pstmt=con.prepareStatement(sSql);
          int nParamField=setFields(dct,1);
    	  pstmt.setInt(nParamField, clave_ext);
    	  nrows=pstmt.executeUpdate();
      	}
      else
    	  	nrows = 1;  // no need to update - no fields!!!!			// releases the statement object
	pstmt.close();
	lastError = ""; // "NO ERROR. sql="+sSql;
	return nrows;
    }
    catch (Exception ex)
    {
    	try{
	    	pstmt.close();
	    }
	    catch(Exception e)
	    {
	    	// do nothing for now
	    }
      //Trap and report SQL errors
      lastError = "<!-Error updating webObject: " + ex.toString() + " : " + sSql + "-->";
    }

    return -1;
  }

  //-------------------------------------------------------------------------------
  // deletes an existing object in the database
  //--------------------------------------------------------------------------------
  public int deleteWebObject(Connection con)
  {

    try
    {
      // creates the statement handle
      stmt = con.createStatement ();

      // SQL_DELETE
      sSql = "DELETE FROM extension";
      sSql += " WHERE (CLAVE_EXT=" + clave_ext + ")";

      nrows = stmt.executeUpdate(sSql);
      // releases the statement object
      stmt.close();
      lastError = ""; // "NO ERROR. sql="+sSql;
      return nrows;
    }
    catch (Exception ex)
    {
      	try{stmt.close();}catch(Exception e){/* do nothing for now */ }
	  //Trap and report SQL errors
      lastError = "<!-Error deleting webObject: " + ex.toString() + " : " + sSql + "-->";
    }
    return -1;
  }
  
 public static String getLegalExtensionFieldName(String sFieldName)
	{
		String sRet=sFieldName.toUpperCase();
		String sNotAcceptable=" -=+/\\!*.#$%^&(){}[]'\"?<>,:;~`";   /// this may be longer if 
		for (int j=0; j<sNotAcceptable.length(); j++)
			if (sRet.indexOf(sNotAcceptable.charAt(j))>=0)
				sRet=sRet.replace(sNotAcceptable.charAt(j), '_');
		
		if (sRet.length()>30)
			sRet=sRet.substring(0,30);
		return sRet;
	}


  public static void main(String[] args)
  {

    extension ext = new extension();

    dbConnection dbCon = null;
    Connection con = null;
    // now, get a connection to the database
    dbCon = new dbConnection("sun.jdbc.odbc.JdbcOdbcDriver", "jdbc:odbc:inventco", "", "");
    boolean bConnectionOK = dbCon.dbGetConnectionStatus();
    // continue if the database is available and ready
    if (bConnectionOK)
    {
      // Conexion OK!!, go and get the data..
      con = dbCon.dbGetConnection();
      ext.loadExtension(con, new DICountry());
    }

  }

}
/*   HTML TEMPLATE
 <table border=0 cellspacing=0 cellpadding=0>
 <tr><td>clave_ext:</td><td>  <INPUT type='TEXT' size='15' maxlength='21' name='clave_ext' VALUE="<%=beanName.clave_ext%>"></td></tr>
 </table>
 */